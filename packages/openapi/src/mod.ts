// deno-lint-ignore no-external-import
import { argv, exit } from 'node:process';
import { parseArgs } from '@std/cli/parse-args';
// deno-lint-ignore no-external-import
import { writeFile } from 'node:fs/promises';
// deno-lint-ignore no-external-import
import { resolve } from 'node:path';
import { generate_paths } from './paths.ts';
import { generate_types } from './schema.ts';
import type { openapi_schema } from './types.ts';

const args = parseArgs(argv.splice(2), {
	string: ['dest', 'url'],
	boolean: ['skip_requests', 'skip_routes'],
	default: {
		dest: '.',
		skip_routes: false,
		skip_requests: false,
	},
});

if (!args.url) {
	console.error('%cYou must supply a url! Use the `--url` flag.', 'color: red');
	exit(1);
}

console.info('%cGenerating code for %s', 'color: blue', args.url);

const schema = await (await fetch(args.url)).json() as openapi_schema;

if (!schema.components?.schemas) {
	console.error('%cNo components found in the OpenAPI schema.', 'color: red');
	exit(1);
}

if (!schema.paths) {
	console.error('%cNo paths found in the OpenAPI schema.', 'color: red');
	exit(1);
}

const seen_operations = new Set<string>();

for (const key of Object.keys(schema.paths)) {
	if ('$ref' in schema.paths[key]) continue;

	for (const method of Object.keys(schema.paths[key])) {
		const item = schema.paths[key][method as 'get'];
		if (!item) continue;
		if ('$ref' in item) continue;

		if (!item.operationId) continue;

		if (seen_operations.has(item.operationId)) {
			item.operationId = `${item.operationId}_${key.split('/')[1]}`;
			schema.paths[key][method as 'get'] = item;
		} else {
			seen_operations.add(item.operationId);
		}
	}
}

let types_file = generate_types(schema.components.schemas);

if (!args.skip_routes) {
	const paths = generate_paths(schema.paths);
	await writeFile(resolve(`${args.dest}/params.ts`), paths.params, 'utf-8');
	await writeFile(resolve(`${args.dest}/routes.ts`), paths.routes, 'utf-8');
	types_file += paths.operations;
}

await writeFile(`${args.dest}/schema.ts`, types_file, 'utf-8');

if (!args.skip_requests) {
	await writeFile(
		resolve(`${args.dest}/mod.ts`),
		`// autogenerated by @jersey/openapi
export { pathResolve, queryParams } from './params.ts';
export type { routes } from './routes.ts';
export type * from './schema.ts';
export * from './request.ts';
`,
		'utf-8'
	);
	await writeFile(
		resolve(`${args.dest}/request.ts`),
		`// autogenerated by @jersey/openapi
import { pathResolve } from './params.ts';
import { queryParams } from './params.ts';
import type { routes } from './routes.ts';

/** Resolve a path */
function path_name(path: string): string | undefined {
	const segments = path.split('/');

	const list =
		(pathResolve as unknown as Record<string, (string | [string])[]>)[
			(segments.length - 1).toString()
		] || [];
	for (const entry of list) {
		let i = 1;
		const copy = [...segments];
		for (i; i < segments.length; i++) {
			if (Array.isArray(entry[i - 1])) {
				copy[i] = entry[i - 1];
				continue;
			} else if (entry[i - 1] !== segments[i]) break;
		}

		if (i === segments.length) return copy.join('/');
	}
}

/**
 * Create a request function
 * @param base_url The base URL to use
 * @param headers The headers to use
 * @returns A request function
 */
export function createRequest(
	base_url: string,
	headers: Record<string, string>,
): request {
	return async (method, path, params) => {
		const query = new URLSearchParams();
		const body = {} as Record<string, unknown>;
		const named = path_name(path);

		if (named && params && typeof params === 'object') {
			const route = queryParams[named as keyof typeof queryParams];
			const allowed_query = (route as Record<typeof method, string[] | undefined>)[method];
			for (const param of Object.keys(params)) {
				if (allowed_query?.includes(param)) {
					query.append(param, (params as Record<string, string>)[param]);
				} else {
					body[param] = (params as Record<string, string>)[param];
				}
			}
		}

		const req_body = ['head', 'get', 'HEAD', 'GET'].includes(method)
			? undefined
			: JSON.stringify(body);
		
		if (['head', 'get', 'HEAD', 'GET'].includes(method)) {
			headers["Content-Type"] = "application/json";
		}

		const query_string = query.size ? \`?\${query.toString()}\` : '';

		const res = await fetch(\`\${base_url}\${path}\${query_string}\`, {
			method,
			headers,
			body: req_body,
		});

		if (res.ok) {
			try {
				return await res.json();
			} catch (e) {
				throw e;
			}
		} else {
			throw new RequestError(method, path, params, res);
		}
	};
}

/**
 * The type of the request function.
 */
export type request = <
	method extends routes['method'],
	path extends Extract<routes, { method: method }>['path'],
	params extends Extract<routes, { method: method; path: path }>['params'],
	response extends Exclude<Extract<routes, { method: method; path: path }>['response'], string>
>(
	method: method,
	path: path,
	params: params,
) => Promise<response>;

/** An error with a request to the API */
export class RequestError extends Error {
	/** The cause of the error from the API */
	override cause: Response;
	/** The HTTP method of the request */
	method: string;
	/** The path of the request */
	path: string;
	/** The parameters of the request */
	params: unknown;

	/** Create an error */
	constructor(method: string, path: string, params: unknown, cause: Response) {
		super(\`Failed to \${method} \${path}: \${cause.status}\`);
		this.name = 'RequestError';
		this.cause = cause;
		this.method = method;
		this.path = path;
		this.params = params;
	}
}
`,
		'utf-8'
	);
}
