import { get_type, ref } from './schema.ts';
import type {
	openapi_operation,
	openapi_parameter,
	openapi_path_item,
	openapi_reference,
	openapi_response,
} from './types.ts';

function indent(level: number) {
	return '\t'.repeat(level);
}

function comment(text: string, level: number) {
	return text ? `${indent(level)}/** ${text} */\n` : '';
}

function handle_path(
	path: string,
	path_segments: Record<string, (string | string[])[][]>,
) {
	const segments = path.split('/').filter(Boolean);
	const segment_count = segments.length.toString();

	const formatted_segments = segments.map((segment) =>
		segment.startsWith('{') && segment.endsWith('}')
			? [`{${segment.slice(1, -1)}}`]
			: segment
	);

	if (!path_segments[segment_count]) path_segments[segment_count] = [];
	path_segments[segment_count].push(formatted_segments);

	return {
		segments,
		template: path.replace(/\{(\w+)\}/g, '${string}'),
		count: segments.length,
	};
}

function handle_params(
	operation: openapi_operation,
	method: string,
	path: string,
	query_params: Record<string, Record<string, string[]>>,
) {
	if (!operation.parameters?.length) return '';

	let result = `${indent(2)}parameters: {\n`;
	const params_by_location: Record<string, openapi_parameter[]> = {};

	operation.parameters.forEach((param) => {
		if ('$ref' in param) return;

		if (param.in === 'header') {
			param.name = param.name.includes('-') ? `'${param.name}'` : param.name;
		}

		if (!params_by_location[param.in]) params_by_location[param.in] = [];
		params_by_location[param.in].push(param);

		if (param.in === 'query') {
			const normalized = path.replace(/{([^}]+)}/g, '{$1}');

			if (!query_params[normalized]) query_params[normalized] = {};
			if (!query_params[normalized][method]) {
				query_params[normalized][method] = [];
			}

			query_params[normalized][method].push(param.name);
		}
	});

	for (const location in params_by_location) {
		result += `${indent(3)}${location}: {\n`;

		for (const param of params_by_location[location]) {
			const type = param.schema ? get_type(param.schema) : 'unknown';
			result += comment(param.description ?? param.name, 4);
			result += `${indent(4)}${param.name}: ${type};\n`;
		}

		result += `${indent(3)}};\n`;
	}

	return result + `${indent(2)}};\n`;
}

function req_body(operation: openapi_operation) {
	if (!operation.requestBody || '$ref' in operation.requestBody) return '';

	let result = `${indent(2)}requestBody: {\n${indent(3)}content: {\n`;

	for (const content_type in operation.requestBody.content) {
		const media_type_obj = operation.requestBody.content[content_type];
		let type = 'unknown';

		if ('$ref' in media_type_obj) {
			type = ref(media_type_obj.$ref);
		} else if (media_type_obj.schema) {
			type = '$ref' in media_type_obj.schema
				? ref(media_type_obj.schema.$ref)
				: get_type(media_type_obj.schema);
		}

		result += `${indent(4)}'${content_type}': ${type};\n`;
	}

	return result + `${indent(3)}};\n${indent(2)}};\n`;
}

function responses(operation: openapi_operation) {
	let result = `${indent(2)}responses: {\n`;

	for (const status_code in operation.responses) {
		const response = operation.responses[status_code];
		result += `${indent(3)}${status_code}: {\n`;

		if ('$ref' in response) {
			result += `${indent(4)}$ref: ${ref(response.$ref)};\n`;
		} else {
			result += comment(response.description, 4);

			if (!response.content || Object.keys(response.content).length === 0) {
				result += `${indent(4)}type: undefined;\n`;
			} else if (response.content) {
				result += `${indent(4)}content: {\n`;

				for (const content_type in response.content) {
					const schema = response.content[content_type].schema;
					if (schema) {
						const type = '$ref' in schema && schema.$ref
							? ref(schema.$ref)
							: get_type(schema);

						result += `${indent(5)}'${content_type}': ${type};\n`;
					}
				}

				result += `${indent(4)}};\n`;
			}
		}

		result += `${indent(3)}};\n`;
	}

	return result + `${indent(2)}};\n`;
}

export function generate_paths(
	paths: Record<string, openapi_path_item | openapi_reference>,
): { operations: string; params: string; routes: string } {
	let operations =
		'/** @description API operations */\nexport interface operations {\n';
	let params =
		'// autogenerated by @jersey/openapi\n/** Path parameter resolution data */\nexport const pathResolve = {\n';

	const route_file_entries = [
		'// autogenerated by @jersey/openapi',
		"import type { operations } from './schema.ts';",
		'/** Automatically generated route definitions based on the OpenAPI schema */',
		'export type routes = ',
	];

	const path_segments: Record<string, (string | string[])[][]> = {};
	const query_params: Record<string, Record<string, string[]>> = {};

	for (const path in paths) {
		const path_item = paths[path];
		if ('$ref' in path_item) continue;

		const { template, count } = handle_path(path, path_segments);

		for (const method in path_item) {
			if (['parameters', 'summary', 'description'].includes(method)) continue;

			const operation = path_item[method as 'get'];
			if (
				!operation || !('operationId' in operation) || !operation.operationId
			) continue;

			operations += comment(
				operation.description || operation.summary || operation.operationId,
				1,
			);
			operations += `${indent(1)}${operation.operationId}: {\n`;
			operations += handle_params(operation, method, path, query_params);
			operations += req_body(operation);
			operations += responses(operation);
			operations += `${indent(1)}};\n`;

			const response_key = Object.keys(operation.responses ?? {}).find((x) =>
				x !== 'default'
			) || 'default';

			if (operation.responses && '$ref' in operation.responses[response_key]) {
				continue;
			}

			const response = operation.responses?.[response_key] as openapi_response;
			const content_type = Object.keys(response?.content || {})[0];

			const response_type = response_key === '204' || !content_type
				? 'undefined'
				: `operations['${operation.operationId}']['responses']['${response_key}']['content']['${content_type}']`;

			const query_parameters = (operation.parameters || [])
				.filter((p) => !('$ref' in p) && p.in === 'query')
				.map((p) => (p as openapi_parameter).name);

			const has_body = operation.requestBody &&
				!('$ref' in operation.requestBody) &&
				operation.requestBody.content['application/json'];

			let parameters = 'undefined';
			if (has_body || query_parameters.length > 0) {
				const entries = [];
				if (query_parameters.length > 0) {
					entries.push(
						`operations['${operation.operationId}']['parameters']['query']`,
					);
				}
				if (has_body) {
					entries.push(
						`operations['${operation.operationId}']['requestBody']['content']['application/json']`,
					);
				}
				parameters = entries.join(' | ');
			}

			route_file_entries.push(
				`\t| { method: '${method}'; path: \`${template}\`; parts: ${count}; params: ${parameters}; response: ${response_type}; }`,
			);

			if (/\{(\w+)\}/.test(path)) {
				route_file_entries.push(
					`\t| { method: '${method}'; path: '-${path}'; parts: ${count}; params: ${parameters}; response: ${response_type}; }`,
				);
			}
		}
	}

	operations += '}\n';

	const sorted_segments = Object.keys(path_segments).sort((a, b) =>
		parseInt(a) - parseInt(b)
	);

	for (const count of sorted_segments) {
		params += `\t'${count}': [\n`;

		for (const segments of path_segments[count]) {
			const formatted = segments.map((segment) =>
				Array.isArray(segment) ? `["${segment}"]` : `'${segment}'`
			).join(', ');

			params += `\t\t[${formatted}],\n`;
		}

		params += `\t],\n`;
	}

	params +=
		'};\n/** Query parameter resolution data */\nexport const queryParams = {\n';

	for (const path in query_params) {
		params += `\t'${path}': { `;

		const methods = Object.entries(query_params[path])
			.map(([method, params]) =>
				`'${method}': [${params.map((p) => `'${p}'`).join(', ')}]`
			)
			.join(', ');

		params += `${methods} },\n`;
	}

	params += '};\n';

	route_file_entries.push(';');

	return { operations, params, routes: route_file_entries.join('\n') };
}
