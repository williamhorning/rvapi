import type { openapi_reference, openapi_schema_object } from './types.ts';

export function ref(ref: string): string {
	return ref.split('/').pop()?.replaceAll('%20', '')?.replaceAll(' ', '') ??
		'unknown';
}

function get_enum(vals?: unknown[]): string | undefined {
	return vals?.length
		? vals.map((v) => JSON.stringify(v)).join(' | ')
		: undefined;
}

function composite(schema: openapi_schema_object): string[] {
	const pick = (k: 'oneOf' | 'anyOf' | 'allOf', sep: string) =>
		schema[k]?.length
			? `(${schema[k].map((i) => get_type(i)).join(` ${sep} `)})`
			: undefined;
	return [
		pick('oneOf', '|'),
		pick('anyOf', '|'),
		pick('allOf', '&'),
	].filter(Boolean) as string[];
}

export function get_type(
	item: openapi_reference | openapi_schema_object,
	is_required = true,
): string {
	if ('$ref' in item) return ref(item.$ref);

	let base = get_enum(item.enum) ??
		(item.type === 'string'
			? 'string'
			: item.type === 'number' || item.type === 'integer'
			? 'number'
			: item.type === 'boolean'
			? 'boolean'
			: item.type === 'null'
			? 'null'
			: item.type === 'array'
			? (() => {
				if (!item.items) return 'unknown[]';
				const items = Array.isArray(item.items)
					? item.items.map((i) => get_type(i)).join(' | ')
					: get_type(item.items);
				return (item as openapi_schema_object).nullable
					? `(${items})[] | null`
					: `(${items})[]`;
			})()
			: item.type === 'object'
			? (() => {
				if (item.properties) {
					const required = item.required || [];

					const props = Object.entries(item.properties)
						.map(
							([k, v]) => {
								const schema = v as openapi_schema_object;
								const prop_required = required.includes(k);
								const optional = !prop_required || schema.nullable;

								return `  ${k}${optional ? '?' : ''}: ${
									get_type(v, prop_required)
								};`;
							},
						)
						.join('\n');
					return `{\n${props}\n}`;
				}

				if (
					item.additionalProperties &&
					typeof item.additionalProperties === 'object'
				) {
					const value = get_type(item.additionalProperties);
					return `Record<string, ${value}>`;
				}

				return 'Record<string, unknown>';
			})()
			: undefined) ??
		'unknown';

	const comps = composite(item);

	if (comps.length) {
		base = base === 'unknown'
			? comps.join(' & ')
			: [base, ...comps].join(' & ');
	}

	if (
		(item as openapi_schema_object).nullable &&
		item.type !== 'array' &&
		is_required
	) {
		base = `${base} | null`;
	}

	return base;
}

export function handle_schema(
	name: string,
	schema: openapi_schema_object,
): string {
	const doc_comment = `/**\n  * @description ${
		schema.description ?? schema.title ?? name
	}\n*/\n`;

	name = name.replaceAll(' ', '').replaceAll('%20', '');

	if (schema.type === 'object' && schema.properties) {
		const required = schema.required || [];

		const body = Object.entries(schema.properties)
			.map(([property_name, property_schema]) => {
				const schema = property_schema as openapi_schema_object;
				const optional = !required.includes(property_name) ||
					schema.nullable;

				const description = schema.description || schema.title || property_name;

				return `  /** @description ${description} */\n  ${property_name}${
					optional ? '?' : ''
				}: ${get_type(property_schema, required.includes(property_name))};`;
			})
			.join('\n');
		const comps = composite(schema);
		if (comps.length) {
			return `${doc_comment}export type ${name} = {\n${body}\n} & ${
				comps.join(' & ')
			}${schema.nullable ? ' | null' : ''}`;
		}
		return `${doc_comment}export interface ${name} {\n${body}\n}`;
	}

	return `${doc_comment}export type ${name} = ${get_type(schema)}`;
}

export function generate_types(
	schema: Record<string, openapi_schema_object>,
): string {
	let output = `// autogenerated by @jersey/openapi\n\n`;

	for (const [name, value] of Object.entries(schema)) {
		output += handle_schema(name, value) + '\n\n';
	}

	return output + '\n\n';
}
