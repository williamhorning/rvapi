import {
	astToString,
	default as openapi,
	type OpenAPI3,
	type PathsObject,
} from 'openapi-typescript';
import { parseArgs } from '@std/cli/parse-args';
// deno-lint-ignore no-external-import
import process from 'node:process';
// deno-lint-ignore no-external-import
import { writeFile } from 'node:fs/promises';

console.info('%cOpenAPI codegen wizard', 'color: blue');

const args = parseArgs(process.argv.slice(2), {
	string: ['url', 'header', 'dest'],
	boolean: ['skip_routes', 'skip_requests'],
	default: {
		header: '// this file was autogenerated by @jersey/openapi\n\n',
		dest: '.',
		skip_routes: false,
		skip_requests: false,
	},
});

if (!args.url) {
	console.error('%cYou must supply a url! Use the `--url` flag.', 'color: red');
	process.exit(1);
}

console.info('%cGenerating code for %s', 'color: blue', args.url);

const schema = await (await fetch(args.url)).json() as OpenAPI3 & {
	paths: PathsObject;
};
const seen_operations = new Set<string>();

for (const key of Object.keys(schema.paths)) {
	if ('$ref' in schema.paths[key]) continue;

	for (const method of Object.keys(schema.paths[key])) {
		const item = schema.paths[key][method as 'get'];
		if (!item) continue;
		if ('$ref' in item) continue;

		if (!item.operationId) continue;

		if (seen_operations.has(item.operationId)) {
			item.operationId = `${item.operationId}_${key.split('/')[1]}`;
			schema.paths[key][method as 'get'] = item;
		} else {
			seen_operations.add(item.operationId);
		}
	}
}

const tree = await openapi(schema, {
	defaultNonNullable: true,
	emptyObjectsUnknown: true,
	rootTypes: true,
	rootTypesNoSchemaPrefix: true,
});

let src = astToString(tree.slice(1));

const replacements = [
	[`        parameters: {\n            query?: never;\n            header?: never;\n            path?: never;\n            cookie?: never;\n        };`],
	[`               headers: {\n                    [name: string]: unknown;\n                };`],
	[`        requestBody?: never;\n`],
	[`            query?: never;\n`],
	[`            header?: never;\n`],
	[`            cookie?: never;\n`],
	[`            path?: never;\n`],
	[`                content?: never;\n`, `                content: never;\n`],
	[`*     `, '* '],
	[`T extends any`, `T extends unknown`],
];

for (const [search, replace] of replacements) {
	src = src.replaceAll(search, replace || '');
}

const methods = [
	'get',
	'put',
	'post',
	'delete',
	'options',
	'head',
	'patch',
	'trace',
];

for (const method of methods) {
	src = src.replaceAll(`        ${method}?: never;\n`, '');
}

await writeFile(
	`${args.dest}/schema.ts`,
	args.header + src,
);

if (!args.skip_routes) {
	const pathFileEntries = [
		args.header,
		"import type { operations } from './schema.ts';",
		'export type routes = ',
	];

	const pathResolve: Record<number, unknown[]> = {};
	const queryData: Record<string, unknown[]> = {};

	for (const path in schema.paths) {
		const data = schema.paths![path];

		if ('$ref' in data) continue;

		const methods = Object.keys(data);
		const template = path.replace(/\{\w+\}/g, '${string}');
		for (const method of methods) {
			const route = data[method as 'get'];

			if (!route || '$ref' in route || !route.responses) continue;

			const operation = `operations['${route.operationId}']`;
			const response = Object.keys(route.responses).find((x) =>
				x !== 'default'
			) || 'default';

			if ('$ref' in route.responses[response]) continue;

			const content_type =
				Object.keys(route.responses[response].content || {})[0];
			const response_type = response === '204' || !content_type
				? 'undefined'
				: `${operation}['responses']['${response}']['content']['${content_type}']`;
			const query_parameters = [];
			let has_body = false;
			if (route['parameters']) {
				for (const parameter of route['parameters']) {
					if ('$ref' in parameter) continue;

					if (parameter.in === 'query') {
						query_parameters.push(parameter.name);
					}
				}
			}
			if (
				route.requestBody && !('$ref' in route.requestBody) &&
				route.requestBody.content['application/json']
			) {
				has_body = true;
			}
			let parameters = 'undefined';
			if (has_body || query_parameters.length > 0) {
				const entries = [];
				if (query_parameters.length > 0) {
					entries.push(`${operation}['parameters']['query']`);
				}
				if (has_body) {
					entries.push(
						`${operation}['requestBody']['content']['application/json']`,
					);
				}
				parameters = entries.join('|');
			}
			const parts = path.split('').filter((x: string) => x === '/').length;
			pathFileEntries.push(
				`| { method: '${method}', path: \`${template}\`, parts: ${parts}, params: ${parameters}, response: ${response_type} }`,
			);
			if (/\{\w+\}/.test(path)) {
				pathFileEntries.push(
					`| { method: '${method}', path: '-${path}', parts: ${parts}, params: ${parameters}, response: ${response_type} }`,
				);
			}
			queryData[path] = {
				...queryData[path],
				[method]: query_parameters,
			};
		}

		const segments = path.split('/');
		segments.shift();
		pathResolve[segments.length] = [
			...(pathResolve[segments.length] || []),
			segments.map((key: string) => /\{.*\}/.test(key) ? [key] : key),
		];
	}

	const routes = pathFileEntries.join('\n') + ';';

	const params = `${args.header}export const pathResolve = ${
		JSON.stringify(pathResolve)
	};\nexport const queryParams = ${JSON.stringify(queryData)};`;

	await writeFile(`${args.dest}/routes.ts`, routes);
	await writeFile(`${args.dest}/params.ts`, params);
}

if (!args.skip_requests) {
	await writeFile(
		`${args.dest}/mod.ts`,
		[
			"export { pathResolve, queryParams } from './params.ts';",
			"export type { routes } from './routes.ts';",
			"export type * from './schema.ts';",
			"export * from './request.ts';",
		].join('\n'),
	);
	await writeFile(
		`${args.dest}/path_name.ts`,
		`import { pathResolve } from './params.ts';

export function path_name(path: string): string | undefined {
	const segments = path.split('/');

	const list =
		(pathResolve as unknown as Record<string, (string | [string])[]>)[
			(segments.length - 1).toString()
		] || [];
	for (const entry of list) {
		let i = 1;
		const copy = [...segments];
		for (i; i < segments.length; i++) {
			if (Array.isArray(entry[i - 1])) {
				copy[i] = entry[i - 1];
				continue;
			} else if (entry[i - 1] !== segments[i]) break;
		}

		if (i === segments.length) return copy.join('/');
	}
}
`,
	);
	await writeFile(
		`${args.dest}/request.ts`,
		`import { path_name } from './path_name.ts';
import { queryParams } from './params.ts';
import type { routes } from './routes.ts';

/**
 * Create a request function
 * @param base_url The base URL to use
 * @param headers The headers to use
 * @returns A request function
 */
export function createRequest(
	base_url: string,
	headers: Record<string, string>,
): request {
	return async (method, path, params) => {
		const query = new URLSearchParams();
		const body = {} as Record<string, unknown>;
		const named = path_name(path);

		if (named && params && typeof params === 'object') {
			const route = queryParams[named as keyof typeof queryParams];
			const allowed_query = (route as Record<typeof method, string[]>)[method];
			for (const param of Object.keys(params)) {
				if (allowed_query.includes(param)) {
					query.append(param, (params as Record<string, string>)[param]);
				} else {
					body[param] = (params as Record<string, string>)[param];
				}
			}
		}

		const req_body = ['head', 'get', 'HEAD', 'GET'].includes(method)
			? undefined
			: JSON.stringify(body);
		
		if (['head', 'get', 'HEAD', 'GET'].includes(method)) {
			headers["Content-Type"] = "application/json";
		}

		const query_string = query.size ? \`?\${query.toString()}\` : '';

		const res = await fetch(\`\${base_url}\${path}\${query_string}\`, {
			method,
			headers,
			body: req_body,
		});

		if (res.ok) {
			try {
				return await res.json();
			} catch (e) {
				throw e;
			}
		} else {
			throw new RequestError(method, path, params, res);
		}
	};
}

/**
 * The type of the request function.
 */
export type request = <
	method extends routes['method'],
	path extends Extract<routes, { method: method }>['path'],
	params extends Extract<routes, { method: method; path: path }>['params'],
	response extends Exclude<Extract<routes, { method: method; path: path }>['response'], string>
>(
	method: method,
	path: path,
	params: params,
) => Promise<response>;

/** An error with a request to the API */
export class RequestError extends Error {
	/** The cause of the error from the API */
	override cause: Response;
	method: string;
	path: string;
	params: unknown;

	/** Create an error */
	constructor(method: string, path: string, params: unknown, cause: Response) {
		super(\`Failed to \${method} \${path}: \${cause.status}\`);
		this.name = 'RequestError';
		this.cause = cause;
		this.method = method;
		this.path = path;
		this.params = params;
	}
}
`,
	);
}
